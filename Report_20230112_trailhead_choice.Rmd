---
title: "Trail head choice"
author: "Jiefeng Kang"
date: "2023-01-12"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 1 Introduction

What are the determine factors of visitor's decision on trail head choices? 
In this analysis, I classified the dailyids by their choices of trail heads, then explored the relationshipe of trail head choices and some factors (weather, holiday/weekend, home distance, visitor group - climbing the mountain and getting to the top or not). 

## 2 Method and results 

### 2.1 Outcome variable

The outcome variable is trail head choice. 
To get trail head choice, we need to get route of each dailyid first. 
Similar to what I have done in cancel-behavior analysis before, I divided the area into several georanges: 

- "data": the range of data-collection, based on the [mountain-climbing route map](https://github.com/kangjf1943/22_BigData4Val); 

- trail heads: defined by related meshes, their names include "yoshida", "gotenba", "suzushiri", and "fujinomiya". 

- "nps": the mountain are inside data collection area, which was based on national parks layer (that is why it is called "nps") and cropped by data collection range area; 

- "top": mountain top, the range of which was defined by the mountain top mesh. 
Take a look at the ranges: 

```{r}
tm_shape(range.data.area) +
  tm_polygons(col = "#9CF6AF") +
  tm_shape(range.nps) +
  tm_polygons(col = "lightblue") +
  tm_shape(range.trailhead) +
  tm_polygons(col = "blue") +
  tm_shape(range.top) +
  tm_polygons(col = "darkblue")
```

Then I got the first log with higher accuracy for each dailyid when s/he enters a new range, and combine them into the actual route of that dailyid, for instance, "outside_data_yoshida_top_yoshida_outside" means a dailyid of round trip getting to the mountain top, while "outside_data_outside" indicates a dailyid of a trip going by the data collection area. 

Then I checked the order of range of each route to get the first trail head they arrive - this is the basic information for the construction of the outcome variable. 

A problem is that we can't use the trail head name directly as outcome variable. The reason is that for different prefectures, the choice priorities of traiheads are different. For example, prefecture A might prefer trail headn Yoshida, while prefecture B might prefer trailhead Gotemba. If we want to use the nominal headtrail variables directly, we need to take prefecture names into our model and that would be too complex (there are 47 prefectures). 

Therefore, to simplify the model, I changed the nominal variable into ordinal variable by the distance between trailheads and prefectures: the closest as "1", and the farthest as "4" since there are 4 trailheads. 
For example, for prefecture A, if A is most close to Yoshida trailhead, than Yoshida trailhead is "1", while if Gotemba trailhead is closest to another prefecture, B, than for B, Gotemba is "1". 
However, on the other hand, I am not sure if this change will cause potential problem: this change of outcome variable is based on the distance, while distance will be used on the model as one of the predictor variables again later. 
Besides, with that change, of course it would be eaiser to analyze the visitors' behavior, but on the other hand, it would be difficult to evaluate the value of each trail head.  

### 2.2 Predictor variables 

The predictor variables include: 

- visitor group: getting to the top or not, and I expected that visitors getting to the top care more about trail head choice, so the choice difference could be larger for this group; 

- weather: I use rain as an example for now; 

- holiday/weekend or not: I expected people will choose more close trailhead if it is not a holiday or weekend (since thy have less time, so they might want to arrive the destination earlier); 

- home distance: I expected that visitors coming from nearby prefectures are more likely to choose closer trailheads, because for them, the difference of different trailhead choices (e.g., 1 hour and 2 hours of 2 different choices) is larger than that of people coming from other prefectures (e.g., 10 hours and 11 hours). 

How do we get the values of the predictor variables? 

- visitor group: whether the dailyid gets to the top or not, including "peak" (get to the top) and "sure_cancel" (not get to the top). 

- weather: I got the data from cancel-behaviro project, the data source is JMA (Japan Meteorological Agency). In this case, I only use rain (unit: mm). 

- holiday/weekend: whether it is a holiday/weekend or not. The values are "True" and "False". 

- distance: the best route from prefecture hall to the target trailhead, generated by `osrm` package. 

### 2.3 Model 

The outcome variable and precitor variables are show as follows (part of the input data): 

```{r}
course.logit2 %>% 
  dplyr::select(dailyid, date, route, trailhead, trailhead_var, 
         visitor_grp, rain_daily_total_mm, holi_wknd, distance) %>% 
  head(20) %>% 
  knitr::kable()
```

I would like to show some basic data exploration. 
That is the number of dailyids choosing different trailhead by prefecture (from top to bottom: average distance of the prefecture and Fujisan larger to lower): 

```{r}
# number of dailyid of each trailhead by pref and distance
course.logit %>% 
  filter(!is.na(prefname)) %>% 
  group_by(trailhead, prefname, distance) %>% 
  summarise(n = n()) %>% 
  ungroup() %>% 
  group_by(prefname) %>% 
  mutate(distance = mean(distance, na.rm = TRUE)) %>% 
  ungroup() %>% 
  ggplot() + 
  geom_point(aes(reorder(prefname, distance), n, col = trailhead)) + 
  coord_flip()
```

From the figure, we know that: 
most visitors come from nearby prefecture; 
the deviation of trailhead choices **seems to be larger** for the prefectures at the bottom. 
To make the second point more clear, I scaled the number of dailyids of each prefecture by maximum values: 

```{r}
course.logit2 %>% 
  group_by(trailhead, prefname, distance) %>% 
  summarise(n = n()) %>% 
  ungroup() %>% 
  group_by(prefname) %>% 
  mutate(
    distance = mean(distance, na.rm = TRUE), 
    n = n / max(n)
  ) %>% 
  ungroup() %>% 
  ggplot() + 
  geom_point(aes(reorder(prefname, distance), n, col = trailhead)) + 
  coord_flip()
```

Now, the result is confusing ... we are not sure if deviation of choices of farther prefectures are lower or not. 

Anyway, I applied individual-based Logit model to the input data, and that is the result: 

```{r}
course.logit2.model <- polr(
  trailhead_var ~ visitor_grp + rain_daily_total_mm + holi_wknd + distance, 
  data = course.logit2, Hess = TRUE
)
summary(course.logit2.model)
```

And the p values of each rows: 

```{r}
ctable %>% knitr::kable()
```

The result is not very straightforward, so I make a virtual predictor dataset and predicted outcome variables to make it easier to understand intuitively (leftside of following figure: not holiday/weekend, rightside: holiday/weekend; up: visitor group getting to the top; down: visitor group not getting to the top). 

```{r}
newdat %>% 
  pivot_longer(cols = c(`1`, `2`, `3`, `4`), 
               names_to = "trailhead", values_to = "prob") %>% 
  ggplot() + 
  geom_line(aes(distance, prob, color = trailhead)) + 
  facet_grid(visitor_grp ~ holi_wknd)
```

As we can see from the results, for all the cells, the choice probabilities of closer trailheads ("1" and "2") decrease with increasing distance, which means, for visitors coming from further places, the attractiveness of closer trailhead is not important. 

Besides, getting-to-top visitors tend to choose closer trailhead: 

```{r}
newdat %>% 
  pivot_longer(cols = c(`1`, `2`, `3`, `4`), 
               names_to = "trailhead", values_to = "prob") %>% 
  ggplot() + 
  geom_line(aes(distance, prob, color = visitor_grp)) + 
  facet_grid(holi_wknd ~ trailhead)
```

But it is weird that visitors choose closer trailheads when it is weekend/holiday ... maybe I should examine the assumptions for the model before applying it: 

```{r}
newdat %>% 
  pivot_longer(cols = c(`1`, `2`, `3`, `4`), 
               names_to = "trailhead", values_to = "prob") %>% 
  ggplot() + 
  geom_line(aes(distance, prob, color = holi_wknd)) + 
  facet_grid(visitor_grp ~ trailhead)
```

## 3 Next step

- Further clean the data, especially to identify the visitor groups by their route more precisely. 

- Improve the model: e.g., test the assumption of the model; take more predictor variables into consideration. 
